import Base: isless
import Base: *, +, -, /

# nanos are base type
# add functionality to convert to Unitful units?

#------------------------------------ encoding system time ------------------------------------#

# system timestamp in Nanos, as generated by time_ns()
struct Nano
    ns::UInt64
    Nano(x::UInt64) = new(x) # ensures maximal efficiency for calling now()
end

Nano(x::Number) = Nano(round(UInt64, abs(x)))

# global t0::UInt64 = time_ns() # changing this may be dangerous
# now() = Nano(time_ns() - t0)
now() = Nano(time_ns())




nanos(x::Number) = Nano(x)
micros(x::Number) = Nano(1e3x)
millis(x::Number) = Nano(1e6x)
secs(x::Number) = Nano(1e9x)

nanos(x::Nano) = x.ns
micros(x::Nano) = x.ns/1e3
millis(x::Nano) = x.ns/1e6
secs(x::Nano) = x.ns/1e9

#MAYBE: use Match.jl? - generalized switch/case
function Base.show(io::IO, t::Nano)
    if t.ns < 1e3
        print(io, "$(t.ns) ns")
    elseif t.ns < 1e6
        print(io, "$(round(t.ns/1e3; digits=3)) Î¼s")
    elseif t.ns < 1e9
        print(io, "$(round(t.ns/1e6; digits=3)) ms")
    else
        print(io, "$(round(t.ns/1e9; digits=3)) sec")
    end
end



#------------------------------------ frequency representation ------------------------------------#

struct Hz
    ns::Nano # period in system time units
end

freq(f::Hz) = secs(1)/f.ns # the frequency in Hz as a number

Hz(f::Union{Number,Nano}) = Hz(secs(1/f))
kHz(f::Union{Number,Nano}) = Hz(millis(1/f))
MHz(f::Union{Number,Nano}) = Hz(micros(1/f))
GHz(f::Union{Number,Nano}) = Hz(nanos(1/f))

Hz(hz::Hz) = 1e9/hz.ns
kHz(hz::Hz) = 1e6/hz.ns
MHz(hz::Hz) = 1e3/hz.ns
GHz(hz::Hz) = 1/hz.ns

# Hz(f::Nano) = Hz()
# kHz(f::Nano) = Hz()
# MHz(f::Nano) = Hz()
# GHz(f::Nano) = Hz()

nanos(hz::Hz) = nanos(hz.ns)
micros(hz::Hz) = micros(hz.ns)
millis(hz::Hz) = millis(hz.ns)
secs(hz::Hz) = secs(hz.ns)


function Base.show(io::IO, f::Hz)
    if freq(f) < 1e3
        print(io, "$(round(freq(f); digits=3)) Hz")
    elseif freq(f) < 1e6
        print(io, "$(round(freq(f)/1e3; digits=3)) kHz")
    elseif freq(f) < 1e9
        print(io, "$(round(freq(f)/1e6; digits=3)) MHz")
    else
        print(io, "$(round(freq(f)/1e9; digits=3)) GHz")
    end
end





#------------------------------------ math and conversion ------------------------------------#

Hz(f::Hz) = f
# Hz(t::Nano) defined as default

Nano(f::Hz) = f.ns
Nano(t::Nano) = t


isless(t1::Nano, t2::Nano) = isless(t1.ns, t2.ns)
isless(f1::Hz, f2::Hz) = isless(freq(f1), freq(f2))


+(t1::Nano, t2::Nano) = Nano(t1.ns + t2.ns)
function -(t1::Nano, t2::Nano)
    if t1 > t2
        Nano(t1.ns - t2.ns)
    else
        Nano(t2.ns - t1.ns)
    end
end

+(f1::Hz, f2::Hz) = Hz(freq(f1) + freq(f2))
-(f1::Hz, f2::Hz) = Hz(freq(f1) - freq(f2))

*(t::Nano, k::Number) = Nano(t.ns*k)
*(k::Number, t::Nano) = Nano(k*t.ns)

*(f::Hz, k::Number) = Hz(freq(f)*k)
*(k::Number, f::Hz) = Hz(k*freq(f))

*(t::Nano, f::Hz) = t/f.ns
*(f::Hz, t::Nano) = t/f.ns

/(t1::Nano, t2::Nano) = t1.ns/t2.ns
/(f1::Hz, f2::Hz) = freq(f1)/freq(f2)

/(t::Nano, k::Number) = Nano(t.ns/k)
/(k::Number, t::Nano) = Hz((1e9k)/t.ns)

/(f::Hz, k::Number) = Hz(freq(f)/k)
/(k::Number, f::Hz) = Nano(k*f.ns)

# define inverse?
#MAYBE: convert to/from DateTime types
#YO: look into a more elegant way of defining this, eg. https://painterqubits.github.io/Unitful.jl/stable/