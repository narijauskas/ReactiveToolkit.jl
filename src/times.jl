import Base: isless
import Base: *, +, -, /


#------------------------------------ encoding system time ------------------------------------#

# system timestamp in nanoseconds, as generated by time_ns()
struct Nanosecond
    ns::UInt64
    Nanosecond(x::UInt64) = new(x) # ensures maximal efficiency for calling now()
end

Nanosecond(x::Number) = Nanosecond(round(UInt64, abs(x)))

now() = Nanosecond(time_ns())

ns(x::Number) = Nanosecond(x)
μs(x::Number) = Nanosecond(1e3x)
ms(x::Number) = Nanosecond(1e6x)
seconds(x::Number) = Nanosecond(1e9x)

#MAYBE: use Match.jl? - generalized switch/case
function Base.show(io::IO, t::Nanosecond)
    if t.ns < 1e3
        print(io, "$(t.ns) ns")
    elseif t.ns < 1e6
        print(io, "$(round(t.ns/1e3; digits=3)) μs")
    elseif t.ns < 1e9
        print(io, "$(round(t.ns/1e6; digits=3)) ms")
    else
        print(io, "$(round(t.ns/1e9; digits=3)) sec")
    end
end



#------------------------------------ frequency representation ------------------------------------#

struct Hz
    ns::Nanosecond # period in system time units
end

freq(f::Hz) = seconds(1)/f.ns # the frequency in Hz as a number

Hz(f::Number) = Hz(seconds(1/f))
kHz(f::Number) = Hz(ms(1/f))
MHz(f::Number) = Hz(μs(1/f))
GHz(f::Number) = Hz(ns(1/f))

function Base.show(io::IO, f::Hz)
    if freq(f) < 1e3
        print(io, "$(round(freq(f); digits=3)) Hz")
    elseif freq(f) < 1e6
        print(io, "$(round(freq(f)/1e3; digits=3)) kHz")
    elseif freq(f) < 1e9
        print(io, "$(round(freq(f)/1e6; digits=3)) MHz")
    else
        print(io, "$(round(freq(f)/1e9; digits=3)) GHz")
    end
end





#------------------------------------ math and conversion ------------------------------------#

Hz(f::Hz) = f
# Hz(t::Nanosecond) defined as default

Nanosecond(f::Hz) = f.ns
Nanosecond(t::Nanosecond) = t


isless(t1::Nanosecond, t2::Nanosecond) = isless(t1.ns, t2.ns)
isless(f1::Hz, f2::Hz) = isless(freq(f1), freq(f2))


+(t1::Nanosecond, t2::Nanosecond) = Nanosecond(t1.ns + t2.ns)
function -(t1::Nanosecond, t2::Nanosecond)
    if t1 > t2
        Nanosecond(t1.ns - t2.ns)
    else
        Nanosecond(t2.ns - t1.ns)
    end
end

+(f1::Hz, f2::Hz) = Hz(freq(f1) + freq(f2))
-(f1::Hz, f2::Hz) = Hz(freq(f1) - freq(f2))

*(t::Nanosecond, k::Number) = Nanosecond(t.ns*k)
*(k::Number, t::Nanosecond) = Nanosecond(k*t.ns)

*(f::Hz, k::Number) = Hz(freq(f)*k)
*(k::Number, f::Hz) = Hz(k*freq(f))

*(t::Nanosecond, f::Hz) = t/f.ns
*(f::Hz, t::Nanosecond) = t/f.ns

/(t1::Nanosecond, t2::Nanosecond) = t1.ns/t2.ns
/(f1::Hz, f2::Hz) = freq(f1)/freq(f2)

/(t::Nanosecond, k::Number) = Nanosecond(t.ns/k)
/(k::Number, t::Nanosecond) = Hz((1e9k)/t.ns)

/(f::Hz, k::Number) = Hz(freq(f)/k)
/(k::Number, f::Hz) = Nanosecond(k*f.ns)

# define inverse?
#MAYBE: convert to/from DateTime types
#YO: look into a more elegant way of defining this, eg. https://painterqubits.github.io/Unitful.jl/stable/