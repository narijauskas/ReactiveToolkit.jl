import Base: isless
import Base: *, +, -, /

# nanos are base type
# add functionality to convert to Unitful units?

#------------------------------------ encoding system time ------------------------------------#

# system timestamp in Nanos, as generated by time_ns()
struct Nanos
    ns::UInt64
    Nanos(x::UInt64) = new(x) # ensures maximal efficiency for calling now() #YO: what?
end

Nanos(x::Number) = Nanos(round(UInt64, abs(x)))
# Nanos(x::UInt64) = Nanos(x)
now() = Nanos(time_ns())

# extended constructors
nanos(x::Number) = Nanos(x)
micros(x::Number) = Nanos(1e3x)
millis(x::Number) = Nanos(1e6x)
seconds(x::Number) = Nanos(1e9x)


# this seems dangerous...
# global t0::UInt64 = time_ns()
# now() = Nanos(time_ns() - t0)




#------------------------------------ frequency representation ------------------------------------#

struct Hz
    nanos::Nanos # period in system time units
end



Hz(f::Union{Number,Nanos}) = Hz(seconds(1/f))
kHz(f::Union{Number,Nanos}) = Hz(millis(1/f))
MHz(f::Union{Number,Nanos}) = Hz(micros(1/f))
GHz(f::Union{Number,Nanos}) = Hz(nanos(1/f))

freq(hz::Hz) = seconds(1)/hz.nanos # the frequency in Hz as a number



# as_Hz(hz::Hz) = 1e9/hz.ns
# as_kHz(hz::Hz) = 1e6/hz.ns
# as_MHz(hz::Hz) = 1e3/hz.ns
# as_GHz(hz::Hz) = 1/hz.ns


#------------------------------------ display methods ------------------------------------#

function Base.show(io::IO, t::Nanos)
    if t.ns < 1e3
        print(io, "$(t.ns) ns")
    elseif t.ns < 1e6
        print(io, "$(round(t.ns/1e3; digits=3)) Î¼s")
    elseif t.ns < 1e9
        print(io, "$(round(t.ns/1e6; digits=3)) ms")
    else
        print(io, "$(round(t.ns/1e9; digits=3)) sec")
    end
end


function Base.show(io::IO, f::Hz)
    if freq(f) < 1e3
        print(io, "$(round(freq(f); digits=3)) Hz")
    elseif freq(f) < 1e6
        print(io, "$(round(freq(f)/1e3; digits=3)) kHz")
    elseif freq(f) < 1e9
        print(io, "$(round(freq(f)/1e6; digits=3)) MHz")
    else
        print(io, "$(round(freq(f)/1e9; digits=3)) GHz")
    end
end

#------------------------------------ as_x functions ------------------------------------#

as_nanos(x::Nanos) = x.ns
as_micros(x::Nanos) = x.ns/1e3
as_millis(x::Nanos) = x.ns/1e6
as_seconds(x::Nanos) = x.ns/1e9

as_nanos(hz::Hz) = nanos(hz.nanos)
as_micros(hz::Hz) = micros(hz.nanos)
as_millis(hz::Hz) = millis(hz.nanos)
as_seconds(hz::Hz) = seconds(hz.nanos)

as_Hz(hz::Hz) = freq(hz)
as_kHz(hz::Hz) = freq(hz)/1e3
as_MHz(hz::Hz) = freq(hz)/1e6
as_GHz(hz::Hz) = freq(hz)/1e9


#------------------------------------ math and conversion ------------------------------------#
#MAYBE: do this thru conversion & promotion rules?

# Hz(t::Nanos) defined by default
Hz(hz::Hz) = hz.nanos

Nanos(hz::Hz) = hz.nanos
Nanos(t::Nanos) = t


isless(t1::Nanos, t2::Nanos) = isless(t1.ns, t2.ns)
isless(f1::Hz, f2::Hz) = isless(freq(f1), freq(f2))


+(t1::Nanos, t2::Nanos) = Nanos(t1.ns + t2.ns)
function -(t1::Nanos, t2::Nanos)
    if t1 > t2
        Nanos(t1.ns - t2.ns)
    else
        Nanos(t2.ns - t1.ns)
    end
end

+(f1::Hz, f2::Hz) = Hz(freq(f1) + freq(f2))
-(f1::Hz, f2::Hz) = Hz(freq(f1) - freq(f2))

*(t::Nanos, k::Number) = Nanos(t.ns*k)
*(k::Number, t::Nanos) = Nanos(k*t.ns)

*(f::Hz, k::Number) = Hz(freq(f)*k)
*(k::Number, f::Hz) = Hz(k*freq(f))

*(t::Nanos, f::Hz) = t/f.nanos
*(f::Hz, t::Nanos) = t/f.nanos

/(t1::Nanos, t2::Nanos) = t1.ns/t2.ns
/(f1::Hz, f2::Hz) = freq(f1)/freq(f2)

/(t::Nanos, k::Number) = Nanos(t.ns/k)
/(k::Number, t::Nanos) = Hz((1e9k)/t.ns)

/(f::Hz, k::Number) = Hz(freq(f)/k)
/(k::Number, f::Hz) = Nanos(k*f.nanos)

# define inverse?
#MAYBE: convert to/from DateTime types
#YO: look into a more elegant way of defining this, eg. https://painterqubits.github.io/Unitful.jl/stable/