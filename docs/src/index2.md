

Julia is the goto language for:
- data analysis, visualization
- system identification, modeling, simulation
- controls synthesis
... but then its time to try running your controller on hardware, and what do you have to do?

Switch to a linux machine, load ROS, remember C++, (or worse, Python), and start configuring CMAKE files.

Alternatively, you avoid julia for the entire project and use a fully integrated toolchain like Matlab/Simulink or Python.


Julia has not solved the two-language problem in robotics. At least not yet. This package aims to take a step towards remedying that.

Think of it as an asyncrhonous, reactive, realtime Simulink.
Simulink, but for scalable, open-source, high-performance hardware I/O.


## Overview
Code is organized into tasks and topics. Tasks do stuff, topics allow data to be shared between them.

Topics are thread-safe containers 
they represent the time-varying states of the system.


!!! note "A simple rule"
    Only share data between tasks using topics.










## Note on Metaprogramming
Macros see inputs as *expressions* that is to say source code as source code.
There are many equivalent syntaxes:

```julia
@topic x::Number = 0
@topic y::Number = 0
function do_stuff()
    y[] = sin(x[])
end
@on x do_stuff()
@on x y[] = sin(x[])
```













## Example

```julia
x = Signal(0.0)
y = Signal(0.0)
@on x begin
    y[] = sin(x[])
end
```

Now, whenever the value of `x` is changed, `y` will be set to `sin(x)` after a slight delay.
```julia
x[] = 1.0
yield()
y[] # returns sin(1.0) after a slight delay
```



## Performance

It is difficult to make fair, direct comparisons between `ReactiveToolkit.jl` and other real-time/robotics frameworks such as ROS or LCM because this package is fairly unique in how it works and what it does. **With this in mind,** consider the basic operation of a concurrent framework: a task reacting to a value generated by another task.

In the context of ROS, this would be a publisher node publishing to a topic and triggering a callback function of a subscriber node. In the context of `ReactiveToolkit.jl`, this would be:
```julia
@topic x = 0
@on x do_something()
x[] = 1
# something is done
```

For such an operation, `ReactiveToolkit.jl` will be some 10,000x faster than ROS.

What?

Again, this is not a fair or direct comparison. ROS nodes are independent processes, and ROS marshalls data between them using TCP/IP. This adds the overhead of serialization, the several steps of the TCP/IP transfer itself, additional transfers to ensure delivery, the OS scheduling the other process, and finally deserialization. In contrast, `ReactiveToolkit.jl` runs within the (preferrably multi-threaded) julia process, and its "nodes" are concurrent tasks with a shared memory pool. Marshalling data becomes a simple matter of mutual exclusion, with the overhead reduced to a few microseconds to acquire a lock.


### Performance vs ROS
- implementation time/effort

one task generating a value, and the other task reacting to it will be some 50,000x faster than ROS.
What? See the note above.
ROS nodes are independent processes, and ROS marshalls data between them using TCP/IP.
This adds the overhead of serialization, the several steps of the TCP/IP transfer itself, the OS scheduler waking the other process, and finally deserialization. In contrast, `ReactiveToolkit.jl` runs inside of the (preferrably multi-threaded) julia process, and its "nodes" are implemented as concurrent tasks. Marshalling data becomes a simple matter of shared memory, with the overhead reduced to a few microseconds to acquire a lock



### What is it?
- a framework for reactive, asynchronous, "soft real-time" programming in julia
- turns out, all we need is the ability to wrap arbitrary code in infinite while loops with a few extra steps
- build-as-you-go ROS inside the REPL, but 10000x faster

### How do you use it?

Topics represent the time-varying states of the system, and can safely share data between tasks. Their current value is used or updated using `[]`.
```julia
# making topics
@topic x = 0
@topic y::Number = 0

# using topics
y[] = sin(x[])
```

ReactiveToolkit also provides several macros to transform arbitrary code into asynchronous tasks which can react to topic updates, time, or arbitrary events.
```julia
# react to topics
@on x y[] = sin(x[])
@on y "y monitor" println("y is now: ", y[])

# react to time
tk1 = @every Hz(10) println("...is this annoying yet?")
tk2 = @after seconds(3) kill(tk1)


tk1 = @every Hz(10) begin
    println("hello! I am a task!")
end begin
    println("...is this annoying yet?")
end begin
    println("goodbye!")
end

# react to events
@loop "serial monitor" println(readline(port))

# stacktraces for debugging
tk3 = @on x throws_error()
# why did my task fail?
debug(tk3)

# these might come in handy :)
kill(ans)
kill(last(rtk_tasks()))
rtk_kill_all()
```


### What can it do?
For a demo, please see the shameless plug of my own research below.
here is an robotic material:

The hardware in this video show

Other than microcontroller firmware, the
The high-level software for this system was written almost entirely in an early version of ReactiveToolkit.





It communicates with 20 independent microcontrollers streaming bidirectional data at 1kHz each, 


and runs hundreds of concurrent tasks.
including hardware drivers
state estimation
global control laws at 

streams motion capture videography data at 240Hz


to achieve heirarchical closed-loop control of 100 channels of prototype soft-robotic actuators, with experimental high-voltage power electronics, and 


This type of performance is not realistic for ROS.
And unlike ROS, it was possible to write, compile, and run new code at runtime.
or modify the code at runtime, while the hardware was running.

parts of the codebase were written in the field, during experiments, and compiled and run on the fly.

### What's the catch?

This approach prioritizes flexibility over safety, robustness, and guardrails.

The target audience is roboticists operating at the intersection of controls theory and experimental hardware.


All communication is unreliable by design. Tasks should be designed with this in mind.

The entire system runs inside of the julia process. In other words, if any code segfaults, all of the code segfaults.

Corollary: This package makes it easy to write code that will segfault.

This package makes it easy to write code that will soft deadlock and consume all CPU resources.

This package is meant to let you use almost 100% of your CPU.
if you ask it to.

The garbage collector will interfere with task timing whenver it feels like it.

New branches of code will have to be compiled, which can take enough time to cause hardware problems.

!!! warning
    In other words, don't use this for your missile. But it may prove useful for your PhD.