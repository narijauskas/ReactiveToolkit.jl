var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"It may be worth familiarizing yourself with the concepts in the Asyncrhonous Programming chapter of the Julia manual before proceeding.","category":"page"},{"location":"manual/#@topic-and-Topics","page":"Manual","title":"@topic & Topics","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Time-varying states are represented by the Topic{T} type. A topic is a thread-safe container holding values of type T. The name is borrowed from ROS; they fulfill a similar role to ROS topics, but work quite differently.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Topics are like (mostly) thread-safe Observables. They are essentially a 2-element circular buffer with mutual exclusion enforced on writes, but allowing unlimited concurrent reads, which reuse the most recently written value. They can be thought of as a Last-In, Only-Out (LIOO?) queue, or simply a thread-safe box containing a variable.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The idea is that the most recent value written to the topic is the most valid representation of that state, older values are obsolete, and discarded. It is generally advised to only have a single task be the \"source\" of the topic.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"T can be any type available in Julia itself: primitive types like UInt16, abstract types like Number, or even Any, dicts or structs encoding custom message types, variable length arrays, images, simulation models, symbolic differential equations, or even julia source code.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"They can be made using the @topic macro, which creates an automatically named topic with an inferred type, bound to the specified variable:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@topic x::Int = 10.0    # x holds Int64s, with initial value of 10\n@topic y::Number = 10.0 # y holds Numbers, initially the Float64 10.0\n@topic z::Number = 10   # z holds Numbers, initially the Int64 10\n@topic a::Any = plot(rand(10)) # the world is your oyster","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"They can also be created manually, for example in loops or generators:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ys = [Topic(0; name=\"y$i\") for i in 1:100]\nzs = [Topic{Float64}(0; name=\"y$i\") for i in 1:100]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The variable represents the topic itself. Their value can be accessed or set using []:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@topic x = 0.0\n@topic y = 0.0\nx[] = 1 # set the value of x\n1 == x[] # use the value of x\ntypeof(x) # Topic{Float64}\ntypeof(x[]) # Float64\ny[] = sin(x[])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that things get tricky when the topic is a mutable type. As a general rule, don't mutate the value of a topic - replace it with a new value instead:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@topic x = [1,2,3]\nx[] = [1,2,3,4] # this is fine\npush!(x[], 5) # this is not","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Once I find an elegant way to automate mutation, I will add it. For now, consider:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"let _x = x[]\n    push!(_x, 5)\n    x[] = _x\nend","category":"page"},{"location":"manual/#@on","page":"Manual","title":"@on","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The @on macro builds a task which will run in response to a topic update. For example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@topic x = 0.0\n@topic y = 0.0\n@on x y[] = sin(x[])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now, whenever x is updated, y will be updated to sin(x).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It expects one of the general forms:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@on topic \"name\" loop_ex\n@on topic \"name\" init_ex loop_ex final_ex","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"topic is the topic to react to\nname is an optional string\ninit_ex is an expression to run once on task creation\nloop_ex is the expression to run on each update to the topic\nfinal_ex is an expression to run once on task destruction","category":"page"},{"location":"manual/#Time","page":"Manual","title":"Time","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ReactiveToolkit uses the Nano type for its internal representation of time, which corresponds to the system clock in nanoseconds as a UInt64. This design choice was made to differentiate ReactiveToolkit's representation of time from the various notions of time provided by other packages, and maintain compatibility between them by requiring explicit conversions to Nanos.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Nanos can be created using the constructors nanos, micros, millis, or seconds, and their operation should be self-explanatory. For convenience, the Hz, kHz, and MHz constructors are also provided, which return the period of the specified frequency in Nanos.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ReactiveToolkit also natively supports conversion from Dates.AbstractTime subtypes, such as Second, Minute, Hour, Day, etc. These can be used in place of the Nano constructors above.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"# the following are equivalent:\n@after Hz(1/60)     do_the_thing()\n@after seconds(60)  do_the_thing()\n@after Second(60)   do_the_thing()\n@after Minute(1)    do_the_thing()","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In fact, it is possible to use any notion of time from any source by defining an appropriate constructor method for Nano:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"struct MartianDay\n    val::Number\nend\n\nNano(d::MartianDay) = Nano(8.86426641e13*d.val)\n\n@every MartianDay(1) println(\"and so, another day goes by on Mars\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ReactiveToolkit.now() returns the current timestamp in Nanos.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ReactiveToolkit.autosleep(t::Nanos) will cycle through various sleep strategies to minimize CPU usage while still maintaining the specified period far more accurately than the OS scheduler would otherwise allow.","category":"page"},{"location":"manual/#@after","page":"Manual","title":"@after","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The @after macro builds a task which will run once on any available thread after a delay. For example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@after seconds(1) println(\"hello from thread $(Threads.threadid())\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It expects the general form:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@after delay \"name\" task_ex","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"delay is the duration of the delay\nname is an optional string\ntask_ex is the expression to delay the execution of","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A useful design pattern is to use @after to control task lifetime:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@after seconds(1) begin\n    i = 0\n    task = @every millis(10) println(\"hello! i is $(i+=1)\")\n    @after seconds(3) kill(task)\nend","category":"page"},{"location":"manual/#@every","page":"Manual","title":"@every","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The @every macro builds a task which will run repeatedly on any available thread at a specified interval. For example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@every seconds(10) println(\"... is this annoying yet?\")\n@every Minute(15) println(\"remember to take a break!\")\n\n# generate a 1Hz sine wave, updated at 100Hz:\n@topic x = 0.0\n@every millis(10) x[] = sin(2Ï€*now()*1e-9)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It expects one of the general forms:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@every interval \"name\" loop_ex\n@every interval \"name\" init_ex loop_ex final_ex","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"interval is the duration of the delay between runs\nname is a string (and is optional)\ninit_ex is an expression to run once on task creation\nloop_ex is the expression to run on each interval\nfinal_ex is an expression to run once on task destruction","category":"page"},{"location":"manual/#@loop","page":"Manual","title":"@loop","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The @loop macro builds a task which will run in response to an arbitrary event. This is the low-level primitive on which @on and @every are built. It is useful for interacting with hardware, or other external processes. Importantly: The user is responsible for ensuring that the loop task expression includes one blocking call to work properly. For example, here is an Arduino-style serial monitor which can be defined directly in the REPL:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using ReactiveToolkit, LibSerialPort\n\nfunction SerialMonitor(addr)\n    # objects can be captured by the task\n    # but kept out of global scope\n    port = SerialPort(addr)\n\n    @loop \"$addr serial monitor\" begin\n        # initializer\n        !isopen(port) && open(port)\n    end begin\n        # loop task\n        println(readline(port))\n    end begin\n        # finalizer\n        isopen(port) && close(port)\n    end\nend\n\ntk = SerialMonitor(\"/dev/ttyACM0\")\n# do stuff\nkill(tk)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This example shows the expanded syntax for including an optional initializer and finalizer in addition to the main loop expression. As mentioned above, loop task expression must inlcude a blocking call to work properly. In the example above, the task waits on readline(port) - thus, it will run whenever a new packet arrives. For contrast, here is a more manual implementation:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using ReactiveToolkit, LibSerialPort\n\nport = SerialPort(\"/dev/ttyACM0\")\nopen(port)\ntk = @loop \"serial monitor\" println(readline(port))\n\nkill(tk)\nclose(port)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is often useful to start with the manual version and build up to re-usable constructors as needed. Note that many older microcontrollers (which use a UART-based FTDI chip to implement USB communication) will also need a baud rate set as the second argument to the SerialPort constructor.","category":"page"},{"location":"manual/#Killing-Tasks","page":"Manual","title":"Killing Tasks","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Tasks are stopped using kill(task):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"tk = @every seconds(0.5) println(\"...is this annoying yet?\")\n# wait for it to get annoying\nkill(tk)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If we forget to bind the task to a variable name (this happens often), it can be found and killed using rtk_tasks().","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that kill only requests that the task stop. The task will continue to wait on its blocking call. If the task is waiting on an external event, it will continue to show as active until that event occurs. I intend to rework the task killing mechanisms to be more robust, transparent, and extensible in the future.","category":"page"},{"location":"extras/#Examples-and-Design-Patterns","page":"Extras","title":"Examples and Design Patterns","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"These are fairly minimal toy examples. Many of them may not be a good idea, or lead to something that is a bad idea. For now, please treat them as food for thought.","category":"page"},{"location":"extras/#Topics-vs-Captured-Variables","page":"Extras","title":"Topics vs Captured Variables","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"As a closure:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"@after seconds(3) begin\n    i = 0\n    task = @every millis(5) println(\"hello! i=$(i+=1)\")\n    @after seconds(3) kill(task)\nend\n# i is not defined","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"As a topic:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"@topic j = 0\n@after seconds(3) begin\n    task = @every millis(5) println(\"hello! j[]=$(j[]+=1)\")\n    @after seconds(3) kill(task)\nend\n# j[] is 600","category":"page"},{"location":"extras/#Timing","page":"Extras","title":"Timing","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"Windows 11 22H2: (Image: timing) ReactiveToolkit.jl: (Image: timing)","category":"page"},{"location":"extras/#Topic/Task-Generators","page":"Extras","title":"Topic/Task Generators","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"Sometimes we want lots of tasks that are almost identical, but with different parameters. Why not use a loop to build them? (see tests_compound.jl)","category":"page"},{"location":"extras/#Custom-Message-Types","page":"Extras","title":"Custom Message Types","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"Since topics can hold any julia type, messages can be defined by whatever type we want. This includes custom structs:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"struct RobotStatus\n    battery_level::Float64\n    is_ok::Bool\nend\n@topic status = RobotStatus(100, true)","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"existing data structures and container types:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"@topic status = (100, true)\n@topic status = Dict(\"battery_level\"=>100, \"is_ok\"=>true)\n@topic status = (battery_level=100, is_ok=true)\n@topic status = \"BATT:100,ISOK:1\"","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"or literally anything:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"@topic status::Any = (100, true)\nstatus[] = Dict(\"battery_level\"=>100, \"is_ok\"=>true)\nstatus[] = \"I hope this doesn't break anything\"","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"You may see why this isn't necessarily a good idea. But it's possible!","category":"page"},{"location":"extras/#Automatic-Plotting","page":"Extras","title":"Automatic Plotting","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"If we lean into the abstraction, we can do things like this:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"using ReactiveToolkit\nusing CairoMakie\n\n@topic idx = 1\n@topic fig = Figure()\n@topic data = Vector{Float64}[]\n\n@on fig \"autosave\" begin\n    save(\"./plots/figure_$(idx[]).png\", fig[])\n    idx[] += 1\nend\n\n@on data \"autoplot\" begin\n    fig[] = lines(data[])\nend\n\n# now we can automatically plot and save data simply by storing it:\ndata[] = rand(10)","category":"page"},{"location":"extras/#Performance","page":"Extras","title":"Performance","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"It is difficult to make fair, direct comparisons between ReactiveToolkit.jl and other real-time/robotics frameworks such as ROS or LCM because this package is fairly unique in how it works and what it does. With this in mind, consider the basic operation of a reactive framework: one task reacting to a value generated by another task.","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"In the context of ROS, this would be a publisher node publishing to a topic and triggering a callback function of a subscriber node. In the context of ReactiveToolkit.jl, this would be:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"@topic x = 0\n@on x do_something()\nx[] = 1\n# something is done","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"For such an operation, ReactiveToolkit.jl will be some 10,000x faster than ROS.","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"What?","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"Again, this is not a fair or direct comparison. ROS nodes are independent processes, and ROS marshalls data between them using TCP/IP. This adds the overhead of serialization, the several steps of the TCP/IP transfer itself, potentially additional transfers to ensure delivery, the OS scheduling the other process, performing a context switch, and finally deserialization. In contrast, ReactiveToolkit.jl runs entirely within a single (preferrably multi-threaded) julia process, and its \"nodes\" are concurrent tasks with a shared memory pool. Marshalling data becomes a simple matter of mutual exclusion, with the overhead reduced to the few microseconds needed to acquire a lock.","category":"page"},{"location":"extras/#Blink","page":"Extras","title":"Blink","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"Blinking an LED on a microcontroller 10 times a second could be done as follows:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"using ReactiveToolkit\nusing LibSerialPort\n\n@topic led_cmd = false\nmcu = SerialPort(\"COM3\")\n\n@every millis(100) \"led blinker\" begin\n    !isopen(mcu) && open(mcu)\nend begin\n    led_cmd[] = !led_cmd[]\n    write(mcu, \"set led $(led_cmd[])\\r\\n\")\nend begin\n    isopen(mcu) && close(mcu)\nend","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"Note that this example assumes a microcontroller with native USB (like a Teensy 4.x or ESP32-S3) on port COM3 with firmware set up to react to the serial commands set led false and set led true. Older microcontrollers (which use a UART-based FTDI chip to implement USB communication) will also need a baud rate set as the second argument to the SerialPort constructor.","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"Also note that serial transfers have a non-negligible latency, so this design pattern is not a good idea above ~200Hz.","category":"page"},{"location":"extras/#Utilities","page":"Extras","title":"Utilities","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"Consider the task which monitors x and prints its value whenever it changes:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"@on x \"x monitor\" println(\"x is now: $(x[])\")","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"A useful design pattern is to wrap a commonly used task template in a constructor function. We can then use and reuse this constructor to generate tasks with behavior that can be customized to a given context via its arguments. For example, this is exactly how we imlement ReactiveToolkit.echo:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"echo(x::AbstractTopic) = @on x \"echo $(x.name)\" println(x.name, \": \", x[])","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"@topic x = 0\necho_x = echo(x)\n# while active, the echo_x task will print the value of x whenever it changes\nkill(echo_x)","category":"page"},{"location":"extras/#Future","page":"Extras","title":"Future","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"Here are some things I'm considering to add in the future:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"operators on topics in the style of eg. Reactive.jl, like merge, filter, foldp, etc.\ncleaner mutation of topics containing mutable types (eg. push!(x[], 5) should work intuitively).\na universal serialization scheme for marshalling of topics.\na cpp implementation of the serializer, to facilitate communication with microcontrollers.\nUDP communication/UDPTopics\nintegration utilities for eg. ROS, LCM, etc.\nbuilt-in support for various interfaces (eg. serial, HID, UDP, etc.)\nthrottling of task updates (user adjustable, defaulting to something like a few MHz)\ncompound triggers like @onany and @onall\npop-up terminal in a separate window dedicated for log/info messages\na clean way to restrict tasks to the main thread for packages which don't play well with multithreading (I've had some issues with Makie.jl jumping threads)\nthread pools and task priorities\ndocumentation on using ReactiveToolkit with existing primitives like Channels\ngraph visualization of the task network\nreal-time plotting\nlogging utilities\nsmarter, more useful, adjustable buffer sizes for topics","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"A UDP backend would allow inter-process and inter-device communication. I have been playing with some prototypes, and almost made it the default Topic type, but chose not to because:","category":"page"},{"location":"extras/","page":"Extras","title":"Extras","text":"UDP is not nearly as fast as shared memory\nUDP requires a good serialization/deserialization scheme\nJulia's UDP stack relies on calls to lib_uv, which I believe are serialized","category":"page"},{"location":"#ReactiveToolkit.jl","page":"Home","title":"ReactiveToolkit.jl","text":"","category":"section"},{"location":"#What-is-it?","page":"Home","title":"What is it?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hello! This package provides some tools to enable asynchronous, concurrent, reactive, \"soft real-time\" programming in Julia. The target audience of this package consists of roboticists working at the intersection of controls theory and experimental hardware. It should prove useful for single developers or small teams who are not willing or able to implement a full real-time stack just to test their control implementation on benchtop hardware.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ReactiveToolkit.jl provides the type Topic{T} to represent a time-varying state of type T that can be shared between concurrently running tasks, and several macros (@on, @every, @after, and @loop) to transform arbitrary code into a network of concurrent tasks, augmented with some added control flow and error handling machinery which will run in reaction to topic updates, time, or arbitrary events.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It also provides some timing functions which efficiently circumvent the limitations of the OS scheduler and help achieve precise, high-frequency task execution. Finally, it provides some utilities for monitoring and managing the execution of tasks (possibly thousands of them).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compared to robotics frameworks like ROS, LCM, or YARP, ReactiveToolkit.jl sacrifices some robustness and safety for tremendous gains in flexibility, ease of use, and often performance. Using an unfair metric, ReactiveToolkit.jl is some 10,000x faster than ROS. (I said unfair - more details coming soon).","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: ReactiveToolkit.jl is not suitable for mission- or safety-critical applications.\nIn other words, don't use this for your missile. But it may prove useful for your PhD.\nPlease read the \"What's the catch?\" section at the bottom of this page before using this package.","category":"page"},{"location":"#What-can-it-do?","page":"Home","title":"What can it do?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a demo, please see the shameless plug of my research below. The hardware in this video is the result of our group's research on the development of intelligent soft robotic materials with integrated sensing, actuation, and control. The high-level software for this system was written almost entirely in an early development version of ReactiveToolkit.jl, which was responsible for both real-time closed loop control (200-600Hz), and data logging at 1kHz. Depending on the mode of operation, this meant simultaneously tracking over 1000 independent states. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"<iframe style=\"width:640px;height:360px\" src=\"https://www.youtube.com/embed/osM1R1PnR2U?rel=0\" title=\"Shape-shifting display for 3D designs\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Running on a modern, but modest PC (Ryzen 7 5800X, 32GB RAM), the software stack handled:","category":"page"},{"location":"","page":"Home","title":"Home","text":"management of bidirectional data streams to 20 microcontrollers at 1kHz each\nprocessing 3D point clouds streamed from a motion capture videography system at 240Hz\nreal-time 3D surface fitting and plotting on a 60Hz monitor using GLMakie.jl\nrecording, storage, and processing of ~1 million data points per second at full send","category":"page"},{"location":"","page":"Home","title":"Home","text":"From a UX/DX perspective, the ability to download dependencies; write, compile, and execute additional robot code at runtime; all with the full OS-agnostic expressiveness and ecosystem of julia at your fingerprints, is... pretty nice, to say the least. Using ReactiveToolkit, many of the demos shown in the video could be written in under a few hours. For example, to generate the radial ripple shown at 0:08:","category":"page"},{"location":"","page":"Home","title":"Home","text":"#=\nThere's certainly a lot I'm not showing here,\nas I'm assuming the \"main\" system stack is already running.\nThis means we already have a bunch of topics defined,\nand have started low-level tasks (eg. hardware drivers, controllers, filters, etc.)\n=#\n\n@topic kt = 30.0 # rate tuning parameter\n@topic kxy = 1.0 # spatial tuning parameter\n\nradial_ripple = @every Hz(200) \"reference\" begin\n    M = 8000 # magnitude (volts)\n    xs = LinRange(-10, 10, 10)\n    ys = LinRange(-10, 10, 10)\n    t = now()*1e-9 # current time in seconds\n    VREF[] = [M*(sin(kxy[]*sqrt(x^2 + y^2) - kt[]*t)+1)/2 for x in xs, y in ys]\nend\n\n# to adjust the shape of the ripple, eg:\nkt[] = 60\nkxy[] = 2\n\n# once we're done filming the demo,\nkill(ripple)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code can be entered directly in the REPL, compiled, and executed while the hardware continues to run. No need to restart hardware, or recompile the full stack!","category":"page"},{"location":"#How-is-it-used?","page":"Home","title":"How is it used?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please consult the Manual for a more detailed description of the API.","category":"page"},{"location":"#What's-the-catch?","page":"Home","title":"What's the catch?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given what ReactiveToolkit.jl is, it is important to understand it's limitations. In no particular order:","category":"page"},{"location":"#.-Soft-Real-Time-is-NOT-Real-Time","page":"Home","title":"1. Soft Real-Time is NOT Real-Time","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReactiveToolkit enables \"soft real-time\" programming in julia. Soft real-time is NOT real-time. Real-time systems make guarantees about the timing of their operations. Soft real-time is the idea that if code runs fast enough, the result is practically the same. Consequently ReactiveToolkit will work well until it can't keep up. While it's actually pretty good at this, it is important to understand that it makes none of the guarantees typically expected of real-time systems. Everything still runs on top of a shared-time OS, and is subject to its whims (at least on Linux there may be ways to circumvent this).","category":"page"},{"location":"#.-Unreliable-Communication","page":"Home","title":"2. Unreliable Communication","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReactiveToolkit is built on top of an unreliable, UDP-like communication system. The objective is for the most recent information to always be available to whichever task desires it, but will drop information if it can't keep up instead of deadlocking. This is by design. Tasks should be designed with this assumption in mind.","category":"page"},{"location":"#.-GC-and-JIT","page":"Home","title":"3. GC and JIT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The reality of Julia is that it has two features which are almost never found in real-time systems: garbage collection and just-in-time compilation. These will both cause your code to freeze unexpectedly, and for unpredictable amounts of time. ReactiveToolkit does nothing to avoid the GC and JIT. This is important to be aware of. It is up to the user to ensure that their code is not triggering garbage collection or compiling functions during critical sections. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The time-to-first-plot problem has not gone away: if your code encounters a new branch, it will take time to compile. This could cause problems, eg. if your drone encounters an obstacle and needs to spend valuable time compiling the obstacle avoidance code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As of 1.9, julia's garbage collector is not concurrent, and will pause all tasks while it runs. When this occurs is entirely unpredictable, and will take an unbounded amount of time to run. Workarounds are to write code that minimize allocations (avoiding them entirely is all but impossible in multi-threaded code) or to pause the GC during critical sections.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GC.enable(false)\n# https://downloadmoreram.com/\nGC.enable(true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Keep an eye on RAM usage in your OS resource monitor - if it reaches 100%, julia will crash. Depending on your code and hardware, this can happen in seconds or in days. A much better solution will come in the form of a task-local/concurrent garbage collector which to my understanding is actively being developed as julia evolves for a multi-threaded world.","category":"page"},{"location":"#.-Multi-Threaded,-Not-Multi-Process","page":"Home","title":"4. Multi-Threaded, Not Multi-Process","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is a common pradigm in robotics to modularize the system into multiple processes with independent memory, which provides robustness against crashes in any part of the system. ReactiveToolkit does not do this (yet), instead, everything runs within one instance of julia and uses a shared memory pool. If you segfault one task, you segfault your entire system. Corollary: you will likely find a way to segfault something.","category":"page"},{"location":"#.-This-is-v0.1.0","page":"Home","title":"5. This is v0.1.0","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This API is still experimental. Please expect it to change. That said, I'd love to hear your feedback on what works and what doesn't, and what you'd like to see in the future!","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReactiveToolkit.jl draws inspiration from Observables.jl, the internals of Makie.jl, robotics frameworks such as LCM, YARP, ROS, block diagram representations of signals and transfer functions from control theory (think Simulink), notions of functional reactive programming [1] [2] including the design of the Elm programming language, and other julia packages for reactive programming such as Reactive.jl, ReactiveBasics.jl, Rocket.jl, and Signals.jl, the composable task-based concurrency system of Julia itself, and a splash of practical experience.","category":"page"}]
}
