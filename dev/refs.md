## References

https://github.com/JuliaGizmos/Reactive.jl
http://juliagizmos.github.io/Reactive.jl/
https://tshort.github.io/ReactiveBasics.jl/stable/
https://github.com/biaslab/Rocket.jl
https://github.com/TsurHerman/Signals.jl/tree/master/src


[Asynchronous Functional Reactive Programming for GUIs](http://people.seas.harvard.edu/~chong/abstracts/CzaplickiC13.html)

@InProceedings{CzaplickiC13,
  author = 	 {Evan Czaplicki and Stephen Chong},
  title = 	 {Asynchronous Functional Reactive Programming for {GUI}s},
  booktitle =    {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  year = 	 2013,
  month = 	 jun,
  pages =        {411--422},
  publisher =    {ACM Press},
  address = 	 {New York, NY, USA}
}

[Concurrent FRP](https://elm-lang.org/assets/papers/concurrent-frp.pdf)



## Future
Check out [Transducers.jl](https://github.com/JuliaFolds/Transducers.jl)




## Topics: @topic

allowing values of type T to be safely and efficiently shared between parts of the system running on multiple threads.


```julia
@topic x = 10
@topic x::Int = 10
```
`@topic` is a macro ultimately creates an object of type `Topic{T}`.

A topic is a threadsafe container holding values of type T. In the example above, `x` is a `Topic{Int}`.

Note that `x` represents the container itself. We need a bit of extra syntax to access the value inside, which looks like this:
```julia
x[] = 1 # set the value of x
sin(x[]) # use the value of x
```



T can be anything you can represent in julia: primitive types like `UInt16`, abstract types like `Number`, dicts or structs encoding custom message types, variable length arrays, images, simulation models, symbolic differential equations, or even julia source code. It can also be of type `Any`.

```julia
@topic x = Trajectory{}
```
```julia
@topic x::Int = 10.0 # x holds Int64s, with initial value of 10
@topic y::Number = 10.0 # y holds Numbers, initially the Float64 10.0
@topic z::Number = 10 # 
@topic a::Any = 10.0

a[] = plot(rand(10))
```

### Custom Message Types
```julia
struct RobotStatus
    battery_level::Float64
    is_ok::Bool
end

@topic status = RobotStatus(100, true)
```

For more flexible messages:
```julia
@topic status = Dict("battery_level"=>100, "is_ok"=>true)
```


<!-- todo: "exotic" example: maybe unicodeplots? images? -->

If we lean into the abstraction, we can do things like this:
```julia
using ReactiveToolkit
using CairoMakie

@topic fig = Figure()

let i = 1
    @on fig "autosave" begin
        save("./data/figure_$i.png", fig[])
        i+=1
    end
end

@on data "autoplot" begin
    fig[] = lines(data[])
end

# now we can automatically plot and save data simply by storing it:
data[] = rand(10)

```




## Tasks

Think of tasks as zero-argument functions (or blocks of code) that can be interrupted and scheduled across CPU cores.

<!-- loop() function example? -->

## Reacting to Changes: @on

General syntax:
```julia
@on "name" topic loop() finalizer()
```
where name and finalizer are optional.

`name` should be a string and is optional
`topic` should be a Topic{T}
`loop()` should be an *expression* describing the loop task
`finalizer()` should be an expression descring the finalizer task, and is optional


```julia
@on x println(x[])
@on "name" topic loop() finalizer()
```

reacting to tasks
The `@on` macro creates tasks which react to updates to a topic.

General syntax:
```julia
@on topic loop_ex
@on topic "name" loop_ex
@on topic "name" init_ex loop_ex final_ex
@on topic init_ex loop_ex final_ex
```
where name and finalizer are optional.

The `topic` and `loop_ex` are required.
A `name` is optional, will be autogenerated otherwise.
A `init_ex` and `final_ex` are optional, but if one is provided, both must be provided.

`name` should be a string and is optional
`topic` should be a ReactiveToolkit `Topic`
`loop()` should be an *expression* describing the loop task
`finalizer()` should be an expression descring the finalizer task, and is optional

The task will update whenever the value of the topic is updated by another task using `topic[] = value`

```julia
@on x println(x[])
@on "name" topic loop() finalizer()
```





## Timing: @at

```julia
@topic led_cmd=false
toggle_led() = led_cmd[] = !led_cmd[]
@at Hz(10) toggle_led()
@on led_cmd write(mcu, "SET LED $led_cmd")
```


## Manual Mode: @loop
This construct exposes the mechanisms for scheduling to the user.
It is particularly useful for eternal interfaces.
`@loop` might be renamed to `@always`
In addition to topics, is the other 'base' primitive of this package. `@on` and `@every` are implemented on top of it.

Think of your code as going inside of a `while true` loop. You are responsible for throttling how fast it runs which resources it blocks.

<!-- TCPIP example? -->
<!-- Serial example -->

```julia
@loop "serial monitor" begin
    !isopen(port) && open(port)
end begin
    x[] = parse(UInt16, readline(port))
end begin # finalizer (optional)
    isopen(port) && close(port)
end
```
In the example above, the task waits on `readline(port)`.

Sometimes, we want to ensure a task runs on the 'main' thread. Especially for packages which are not multithreaded, like making plots with `GLMakie`.
```julia
@looplocal "realtime plot" begin
    wait(x)
    plot!(ax, x[])
end
```
The code above is functionally identical to:
```julia
@on x plot!(ax, x[])
```
except it will not jump between multiple threads.



## Extendability @loop
custom tasks
along with topics this is the basic building block of the package
`@on` and `@every` are implemented using `@loop`

## Stopping Tasks
Tasks are stopped using `kill(task)`:
```julia
tk = @every seconds(0.5) println("...is this annoying yet?")
# wait for it to get annoying
kill(tk)
```

If we forget to bind the task to a variable name (this happens often), it can be found and killed using `rtk_tasks()`.

Note that kill only *requests* that the task stop. The task will continue to wait on its blocking call. If the task is waiting on an external event, it will continue to show as `active` until that event occurs. I intend to rework the task killing mechanisms to be more robust, transparent, and extensible in the future.


## Reacting to Groups: On Any/On All

To run a task in response to a change in any element x1,x2,x3

```julia
@onany (x1,x2,x3) anytask()
@onall (x1,x2,x3) alltask()
```





## Utilities
rtk_tasks()
rtk_topics() <- maybe
rtk_kill_all()
rtk_clean()


Consider the task which monitors x and prints its value whenever it changes:
```julia
@on x "x monitor" println("x is now: $(x[])")
```

A useful design pattern is to wrap a commonly used task template in a constructor function.
We can then use and reuse this constructor to generate tasks with behavior that can be customized to a given context via its arguments. For example, this is exactly how we imlement `ReactiveToolkit.echo`:

```julia
echo(x::AbstractTopic) = @on x "echo $(x.name)" println(x.name, ": ", x[])
```

```julia
@topic x = 0
echo_x = echo(x)
# while active, the echo_x task will print the value of x whenever it changes
kill(echo_x)
```




## @every - Timed Repetition
<!-- `@at` was also considered, but makes less sense beyond Hz -->

```julia
@every seconds(1) println("...is this annoying yet?")
```

will accept ReactiveToolkit.jl timing types (`Nano`s)
`nanos`
`micros`
`millis`
`seconds`

one of the constructor functions for `Nano`, ReactiveToolkit's internal timing type. These constructors are `nanos`, `micros`, `millis`, and `seconds`, and their use should be self-explanatory.

The name `Nano` was chosen to differentiate our idea of nanoseconds from any other packages which provide notions of time, and maintain compatability between them.

ReactiveToolkit natively supports `Dates.AbstractTime` subtypes, such as `Second`, `Minute`, `Hour`, `Day`, etc.

```julia
@every Minute(10) println("remember to take occasional breaks")
```

The snippet below was taken after the code had been running for a few hours. Note that the time is not exactly 10 minutes apart, but within several milliseconds. This is close enough for most purposes.
```
the time is now 2023-11-13T11:58:10.843, remember to take a break!
the time is now 2023-11-13T11:59:10.842, remember to take a break!
the time is now 2023-11-13T12:00:10.831, remember to take a break!
the time is now 2023-11-13T12:01:10.845, remember to take a break!
the time is now 2023-11-13T12:02:10.834, remember to take a break!
the time is now 2023-11-13T12:03:10.830, remember to take a break!
the time is now 2023-11-13T12:04:10.839, remember to take a break!
the time is now 2023-11-13T12:05:10.840, remember to take a break!
the time is now 2023-11-13T12:06:10.838, remember to take a break!
the time is now 2023-11-13T12:07:10.833, remember to take a break!
the time is now 2023-11-13T12:08:10.836, remember to take a break!
the time is now 2023-11-13T12:09:10.833, remember to take a break!
the time is now 2023-11-13T12:10:10.839, remember to take a break!
the time is now 2023-11-13T12:11:10.839, remember to take a break!
the time is now 2023-11-13T12:12:10.841, remember to take a break!
the time is now 2023-11-13T12:13:10.843, remember to take a break!
the time is now 2023-11-13T12:14:10.840, remember to take a break!
the time is now 2023-11-13T12:15:10.839, remember to take a break!
the time is now 2023-11-13T12:16:10.838, remember to take a break!
the time is now 2023-11-13T12:17:10.844, remember to take a break!
the time is now 2023-11-13T12:18:10.832, remember to take a break!
the time is now 2023-11-13T12:19:10.836, remember to take a break!
the time is now 2023-11-13T12:20:10.841, remember to take a break!
the time is now 2023-11-13T12:21:10.836, remember to take a break!
the time is now 2023-11-13T12:22:10.846, remember to take a break!
the time is now 2023-11-13T12:23:10.839, remember to take a break!
the time is now 2023-11-13T12:24:10.841, remember to take a break!
the time is now 2023-11-13T12:25:10.845, remember to take a break!
```

Code that doesn't use print statements and smaller intervals will be more accurate, often down to the tens of microseconds.


In fact, it is possible to use any notion of time as long as the appropriate constructor for `Nano` is defined:
```julia
struct Hz
    hz::Float64
end

ReactiveToolkit.Nano(x::Hz) = Nano(1e9/Hz.hz)

@every Hz(3) println("this will run 3 times per second")

```

