<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · ReactiveToolkit.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="ReactiveToolkit.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="ReactiveToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ReactiveToolkit.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#@topic-and-Topics"><span>@topic &amp; Topics</span></a></li><li><a class="tocitem" href="#@on"><span>@on</span></a></li><li><a class="tocitem" href="#Time"><span>Time</span></a></li><li><a class="tocitem" href="#@after"><span>@after</span></a></li><li><a class="tocitem" href="#@every"><span>@every</span></a></li><li><a class="tocitem" href="#@loop"><span>@loop</span></a></li><li><a class="tocitem" href="#Killing-Tasks"><span>Killing Tasks</span></a></li></ul></li><li><a class="tocitem" href="../extras/">Extras</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/narijauskas/ReactiveToolkit.jl/blob/main/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>It may be worth familiarizing yourself with the concepts in the <a href="https://docs.julialang.org/en/v1/manual/asynchronous-programming/">Asyncrhonous Programming</a> chapter of the Julia manual before proceeding.</p><h2 id="@topic-and-Topics"><a class="docs-heading-anchor" href="#@topic-and-Topics">@topic &amp; Topics</a><a id="@topic-and-Topics-1"></a><a class="docs-heading-anchor-permalink" href="#@topic-and-Topics" title="Permalink"></a></h2><p>Time-varying states are represented by the <code>Topic{T}</code> type. A topic is a thread-safe container holding values of type <code>T</code>. The name is borrowed from ROS; they fulfill a similar role to ROS topics, but work quite differently.</p><p>Topics are like (mostly) thread-safe Observables. They are essentially a 2-element circular buffer with mutual exclusion enforced on writes, but allowing unlimited concurrent reads, which reuse the most recently written value. They can be thought of as a Last-In, Only-Out (LIOO?) queue, or simply a thread-safe box containing a variable.</p><p>The idea is that the most recent value written to the topic is the most valid representation of that state, older values are obsolete, and discarded. It is generally advised to only have a single task be the &quot;source&quot; of the topic.</p><p><code>T</code> can be any type available in Julia itself: primitive types like <code>UInt16</code>, abstract types like <code>Number</code>, or even <code>Any</code>, dicts or structs encoding custom message types, variable length arrays, images, simulation models, symbolic differential equations, or even julia source code.</p><p>They can be made using the <code>@topic</code> macro, which creates an automatically named topic with an inferred type, bound to the specified variable:</p><pre><code class="language-julia hljs">@topic x::Int = 10.0    # x holds Int64s, with initial value of 10
@topic y::Number = 10.0 # y holds Numbers, initially the Float64 10.0
@topic z::Number = 10   # z holds Numbers, initially the Int64 10
@topic a::Any = plot(rand(10)) # the world is your oyster</code></pre><p>They can also be created manually, for example in loops or generators:</p><pre><code class="language-julia hljs">ys = [Topic(0; name=&quot;y$i&quot;) for i in 1:100]
zs = [Topic{Float64}(0; name=&quot;y$i&quot;) for i in 1:100]</code></pre><p>The variable represents the topic itself. Their value can be accessed or set using <code>[]</code>:</p><pre><code class="language-julia hljs">@topic x = 0.0
@topic y = 0.0
x[] = 1 # set the value of x
1 == x[] # use the value of x
typeof(x) # Topic{Float64}
typeof(x[]) # Float64
y[] = sin(x[])</code></pre><p>Note that things get tricky when the topic is a mutable type. <strong>As a general rule, don&#39;t mutate the value of a topic</strong> - replace it with a new value instead:</p><pre><code class="language-julia hljs">@topic x = [1,2,3]
x[] = [1,2,3,4] # this is fine
push!(x[], 5) # this is not</code></pre><p>Once I find an elegant way to automate mutation, I will add it. For now, consider:</p><pre><code class="language-julia hljs">let _x = x[]
    push!(_x, 5)
    x[] = _x
end</code></pre><h2 id="@on"><a class="docs-heading-anchor" href="#@on">@on</a><a id="@on-1"></a><a class="docs-heading-anchor-permalink" href="#@on" title="Permalink"></a></h2><p>The <code>@on</code> macro builds a task which will run in response to a topic update. For example:</p><pre><code class="language-julia hljs">@topic x = 0.0
@topic y = 0.0
@on x y[] = sin(x[])</code></pre><p>Now, whenever <code>x</code> is updated, <code>y</code> will be updated to <code>sin(x)</code>.</p><p>It expects one of the general forms:</p><pre><code class="language-julia hljs">@on topic &quot;name&quot; loop_ex
@on topic &quot;name&quot; init_ex loop_ex final_ex</code></pre><ul><li><code>topic</code> is the topic to react to</li><li><code>name</code> is an optional string</li><li><code>init_ex</code> is an expression to run once on task creation</li><li><code>loop_ex</code> is the expression to run on each update to the topic</li><li><code>final_ex</code> is an expression to run once on task destruction</li></ul><h2 id="Time"><a class="docs-heading-anchor" href="#Time">Time</a><a id="Time-1"></a><a class="docs-heading-anchor-permalink" href="#Time" title="Permalink"></a></h2><p>ReactiveToolkit uses the <code>Nano</code> type for its internal representation of time, which corresponds to the system clock in nanoseconds as a <code>UInt64</code>. This design choice was made to differentiate ReactiveToolkit&#39;s representation of time from the various notions of time provided by other packages, and maintain compatibility between them by requiring explicit conversions to <code>Nano</code>s.</p><p><code>Nano</code>s can be created using the constructors <code>nanos</code>, <code>micros</code>, <code>millis</code>, or <code>seconds</code>, and their operation should be self-explanatory. For convenience, the <code>Hz</code>, <code>kHz</code>, and <code>MHz</code> constructors are also provided, which return the period of the specified frequency in <code>Nano</code>s.</p><p>ReactiveToolkit also natively supports conversion from <code>Dates.AbstractTime</code> subtypes, such as <code>Second</code>, <code>Minute</code>, <code>Hour</code>, <code>Day</code>, etc. These can be used in place of the <code>Nano</code> constructors above.</p><pre><code class="language-julia hljs"># the following are equivalent:
@after Hz(1/60)     do_the_thing()
@after seconds(60)  do_the_thing()
@after Second(60)   do_the_thing()
@after Minute(1)    do_the_thing()</code></pre><p>In fact, it is possible to use any notion of time from any source by defining an appropriate constructor method for <code>Nano</code>:</p><pre><code class="language-julia hljs">struct MartianDay
    val::Number
end

Nano(d::MartianDay) = Nano(8.86426641e13*d.val)

@every MartianDay(1) println(&quot;and so, another day goes by on Mars&quot;)</code></pre><p><code>ReactiveToolkit.now()</code> returns the current timestamp in <code>Nano</code>s.</p><p><code>ReactiveToolkit.autosleep(t::Nanos)</code> will cycle through various sleep strategies to minimize CPU usage while still maintaining the specified period far more accurately than the OS scheduler would otherwise allow.</p><h2 id="@after"><a class="docs-heading-anchor" href="#@after">@after</a><a id="@after-1"></a><a class="docs-heading-anchor-permalink" href="#@after" title="Permalink"></a></h2><p>The <code>@after</code> macro builds a task which will run once on any available thread after a delay. For example:</p><pre><code class="language-julia hljs">@after seconds(1) println(&quot;hello from thread $(Threads.threadid())&quot;)</code></pre><p>It expects the general form:</p><pre><code class="language-julia hljs">@after delay &quot;name&quot; task_ex</code></pre><ul><li><code>delay</code> is the duration of the delay</li><li><code>name</code> is an optional string</li><li><code>task_ex</code> is the expression to delay the execution of</li></ul><p>A useful design pattern is to use <code>@after</code> to control task lifetime:</p><pre><code class="language-julia hljs">@after seconds(1) begin
    i = 0
    task = @every millis(10) println(&quot;hello! i is $(i+=1)&quot;)
    @after seconds(3) kill(task)
end</code></pre><h2 id="@every"><a class="docs-heading-anchor" href="#@every">@every</a><a id="@every-1"></a><a class="docs-heading-anchor-permalink" href="#@every" title="Permalink"></a></h2><p>The <code>@every</code> macro builds a task which will run repeatedly on any available thread at a specified interval. For example:</p><pre><code class="language-julia hljs">@every seconds(10) println(&quot;... is this annoying yet?&quot;)
@every Minute(15) println(&quot;remember to take a break!&quot;)

# generate a 1Hz sine wave, updated at 100Hz:
@topic x = 0.0
@every millis(10) x[] = sin(2π*now()*1e-9)</code></pre><p>It expects one of the general forms:</p><pre><code class="language-julia hljs">@every interval &quot;name&quot; loop_ex
@every interval &quot;name&quot; init_ex loop_ex final_ex</code></pre><ul><li><code>interval</code> is the duration of the delay between runs</li><li><code>name</code> is a string (and is optional)</li><li><code>init_ex</code> is an expression to run once on task creation</li><li><code>loop_ex</code> is the expression to run on each interval</li><li><code>final_ex</code> is an expression to run once on task destruction</li></ul><h2 id="@loop"><a class="docs-heading-anchor" href="#@loop">@loop</a><a id="@loop-1"></a><a class="docs-heading-anchor-permalink" href="#@loop" title="Permalink"></a></h2><p>The <code>@loop</code> macro builds a task which will run in response to an arbitrary event. This is the low-level primitive on which <code>@on</code> and <code>@every</code> are built. It is useful for interacting with hardware, or other external processes. <strong>Importantly: The user is responsible for ensuring that the loop task expression includes one blocking call to work properly.</strong> For example, here is an Arduino-style serial monitor which can be defined directly in the REPL:</p><pre><code class="language-julia hljs">using ReactiveToolkit, LibSerialPort

function SerialMonitor(addr)
    # objects can be captured by the task
    # but kept out of global scope
    port = SerialPort(addr)

    @loop &quot;$addr serial monitor&quot; begin
        # initializer
        !isopen(port) &amp;&amp; open(port)
    end begin
        # loop task
        println(readline(port))
    end begin
        # finalizer
        isopen(port) &amp;&amp; close(port)
    end
end

tk = SerialMonitor(&quot;/dev/ttyACM0&quot;)
# do stuff
kill(tk)</code></pre><p>This example shows the expanded syntax for including an optional initializer and finalizer in addition to the main loop expression. As mentioned above, loop task expression <strong>must</strong> inlcude a blocking call to work properly. In the example above, the task waits on <code>readline(port)</code> - thus, it will run whenever a new packet arrives. For contrast, here is a more manual implementation:</p><pre><code class="language-julia hljs">using ReactiveToolkit, LibSerialPort

port = SerialPort(&quot;/dev/ttyACM0&quot;)
open(port)
tk = @loop &quot;serial monitor&quot; println(readline(port))

kill(tk)
close(port)</code></pre><p>It is often useful to start with the manual version and build up to re-usable constructors as needed. Note that many older microcontrollers (which use a UART-based FTDI chip to implement USB communication) will also need a baud rate set as the second argument to the SerialPort constructor.</p><h2 id="Killing-Tasks"><a class="docs-heading-anchor" href="#Killing-Tasks">Killing Tasks</a><a id="Killing-Tasks-1"></a><a class="docs-heading-anchor-permalink" href="#Killing-Tasks" title="Permalink"></a></h2><p>Tasks are stopped using <code>kill(task)</code>:</p><pre><code class="language-julia hljs">tk = @every seconds(0.5) println(&quot;...is this annoying yet?&quot;)
# wait for it to get annoying
kill(tk)</code></pre><p>If we forget to bind the task to a variable name (this happens often), it can be found and killed using <code>rtk_tasks()</code>.</p><p>Note that kill only <em>requests</em> that the task stop. The task will continue to wait on its blocking call. If the task is waiting on an external event, it will continue to show as <code>active</code> until that event occurs. I intend to rework the task killing mechanisms to be more robust, transparent, and extensible in the future.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../extras/">Extras »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 27 November 2023 02:49">Monday 27 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
